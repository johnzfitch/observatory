<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="description" content="AI Observatory - Advanced deepfake detection using WebGPU acceleration">
  <!-- iOS Safari: Dark theme to prevent white flashes -->
  <meta name="theme-color" content="#0d0a1a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>AI Observatory - Deepfake Detection</title>
  <!-- Security: Content Security Policy -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self';
                 script-src 'self' 'unsafe-inline' 'unsafe-eval' 'wasm-unsafe-eval' blob: https://cdn.jsdelivr.net;
                 script-src-elem 'self' 'unsafe-inline' blob: https://cdn.jsdelivr.net;
                 style-src 'self' 'unsafe-inline';
                 img-src 'self' blob: data:;
                 worker-src 'self' blob: https://cdn.jsdelivr.net;
                 connect-src 'self' blob: data: https://cdn.jsdelivr.net https://huggingface.co;">

  <!-- Fonts (Local - No External CDN) -->
  <link rel="stylesheet" href="fonts/fonts.css">

  <!-- Styles -->
  <link rel="stylesheet" href="src/ui/styles.css">
</head>
<body>
  <!-- ============================================ -->
  <!-- PHASE 1 CRITICAL SCRIPTS - ORDER MATTERS!   -->
  <!-- ============================================ -->

  <!-- 1. Emergency cache clear (runs synchronously, may reload page) -->
  <!-- DISABLED: Causes reload loop. Use /sw-fix.html for manual cache clear -->
  <!-- <script src="/patches/001-cache-nuclear.js"></script> -->

  <!-- 2. ONNX pre-initialization (sets global config before any imports) -->
  <script src="/src/config/onnx-init.js"></script>

  <!-- ============================================ -->

  <!-- Progress Tracker Container (for model loading progress) -->
  <div id="progress-tracker" class="progress-tracker-container"></div>

  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <div class="loading-text">Initializing AI Observatory...</div>
      <div class="loading-subtext" id="loadingSubtext">Detecting compute backend...</div>
    </div>
  </div>

  <!-- Matrix Rain Background -->
  <canvas id="matrixRain" class="matrix-rain"></canvas>

  <!-- Main Container -->
  <div class="container">
    <!-- Header -->
    <header>
      <img src="/browser/images/ai-magnifying-glass-detected.png" alt="The Observatory" class="logo">
      <div class="brand">
        <h1>The Observatory</h1>
        <p class="tagline">Detect whether an image was generated via AI or Human.</p>
      </div>
      <div class="header-branding">
        <img src="/browser/images/sponsored-by-internet-universe-org.png" alt="Internet Universe">
      </div>
    </header>

    <div class="backend-info">
      <span class="backend-label">Inference Backend:</span>
      <span class="backend-value loading" id="backendValue">Detecting...</span>
      <span style="margin-left: auto; color: var(--text-muted);">All processing runs locally in your browser</span>
      <button class="clear-cache-btn" id="clearCacheBtn" title="Clear all cached data and reload">Clear Cache</button>
    </div>

    <!-- Upload Zone (MOVED TO TOP) -->
    <div class="upload-zone" id="uploadZone">
      <input type="file" class="upload-input" id="fileInput" accept="image/*">

      <div class="upload-placeholder">
        <svg class="upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/>
        </svg>
        <p class="upload-text"><strong>Drop Image Here</strong> or click to browse</p>
        <p class="upload-hint">PNG, JPG, WEBP - All processing is local</p>
      </div>

      <div class="preview-container">
        <img class="preview-image" id="previewImage" src="" alt="Preview">
        <div class="preview-info">
          <span class="preview-name" id="fileName">image.png</span>
          <button class="preview-remove" id="removeBtn">Remove</button>
        </div>
      </div>
    </div>

    <!-- Model Info Card -->
    <div class="model-info-card">
      <div class="model-info-header">
        <div class="model-info-badge">
          <svg class="model-badge-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
          </svg>
          <span>AI Detection Engine</span>
        </div>
        <div class="model-info-status" id="modelStatus">
          <span class="status-dot"></span>
          <span class="status-text">Loading...</span>
        </div>
      </div>

      <div class="model-info-content">
        <div class="model-info-main">
          <h3 class="model-info-title">Ateeqq AI vs Human Detector</h3>
          <p class="model-info-subtitle">SigLIP Vision Transformer · 99.23% Accuracy</p>
          <p class="model-info-description">
            Fine-tuned on the latest AI generators including Midjourney v6.1, Flux 1.1 Pro,
            Stable Diffusion 3.5, and GPT-4o image outputs.
          </p>
        </div>

        <div class="model-info-features">
          <div class="feature-item" id="featureWebGPU">
            <div class="feature-icon webgpu">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M13 10V3L4 14h7v7l9-11h-7z"/>
              </svg>
            </div>
            <div class="feature-text">
              <span class="feature-label">WebGPU Accelerated</span>
              <span class="feature-value" id="gpuStatus">Detecting...</span>
            </div>
          </div>

          <div class="feature-item">
            <div class="feature-icon privacy">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
              </svg>
            </div>
            <div class="feature-text">
              <span class="feature-label">100% Private</span>
              <span class="feature-value">No server upload</span>
            </div>
          </div>

          <div class="feature-item">
            <div class="feature-icon model">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4"/>
              </svg>
            </div>
            <div class="feature-text">
              <span class="feature-label">Model Size</span>
              <span class="feature-value">56 MB ONNX</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Progress Bar Container for Analysis -->
    <div id="analysisProgress" class="analysis-progress" style="display: none;">
      <div class="progress-text">Preparing analysis...</div>
      <div class="progress-bar-wrapper">
        <div class="progress-bar" style="width: 0%"></div>
      </div>
    </div>

    <!-- Analyze Button -->
    <button class="analyze-btn" id="analyzeBtn" disabled>
      <span class="btn-text">Loading models...</span>
    </button>

    <!-- New Analysis Button (hidden until results shown) -->
    <button id="newAnalysisBtn" class="new-analysis-btn" style="display: none;">
      New Analysis
    </button>

    <!-- Results Panel -->
    <div class="results-panel" id="resultsPanel">
      <div class="scanning-state" id="scanningState">
        <svg class="scanning-icon" viewBox="0 0 24 24" fill="none" stroke="var(--cyan)" stroke-width="1.5">
          <circle cx="12" cy="12" r="10"/>
          <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
        </svg>
        <p class="scanning-text" id="scanningText">Analyzing image...</p>
        <p class="scanning-subtext" id="scanningSubtext">Running detection models</p>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <div class="model-progress-list" id="modelProgressList"></div>
      </div>

      <div id="resultsContent" class="hidden">
        <div class="results-header">
          <svg class="results-icon" id="resultIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="12" cy="12" r="10"/>
          </svg>
          <div class="results-title-group">
            <h3 class="results-title" id="resultTitle">Analysis Complete</h3>
            <p class="results-subtitle" id="resultSubtitle">Results from browser-based detection</p>
          </div>
          <div class="results-confidence">
            <div class="confidence-value" id="confidenceValue">--</div>
            <div class="confidence-label">Confidence</div>
          </div>
        </div>

        <div class="results-body">
          <!-- Ensemble Result Section -->
          <div class="ensemble-section">
            <div class="ensemble-header">
              <h4>Ensemble Prediction</h4>
              <span class="ensemble-formula">Ateeqq AI Detector (99.23% accuracy)</span>
            </div>

            <div class="ai-probability-meter">
              <div class="probability-labels">
                <span class="prob-label prob-human">0% Human</span>
                <span class="prob-label prob-ai">100% AI</span>
              </div>
              <div class="probability-bar">
                <div class="probability-fill" id="probabilityFill" style="width: 50%"></div>
                <div class="probability-marker" id="probabilityMarker" style="left: 50%">
                  <span class="probability-value" id="probabilityMarkerValue">50%</span>
                </div>
              </div>
            </div>

            <div class="perf-stats">
              <div class="perf-stat">
                <span class="perf-label">Total Time</span>
                <span class="perf-value" id="totalTime">--</span>
              </div>
              <div class="perf-stat">
                <span class="perf-label">Avg/Model</span>
                <span class="perf-value" id="avgTime">--</span>
              </div>
            </div>
          </div>

          <!-- Individual Model Analysis -->
          <div class="models-section">
            <div class="section-header">
              <h4>Individual Model Analysis</h4>
              <span class="section-subtitle">Each model's prediction, weight, and training data</span>
            </div>

            <div class="model-cards" id="modelCards">
              <!-- Model cards will be inserted here by JavaScript -->
            </div>
          </div>

          <!-- Methodology & Interpretation -->
          <div class="methodology-section">
            <div class="section-header">
              <h4>Methodology & Interpretation</h4>
              <span class="section-subtitle">Understanding ensemble weights and how to read results</span>
            </div>

            <div class="methodology-content">
              <div class="methodology-column">
                <h5>Ensemble Formula</h5>
                <div class="formula-display">
                  <div class="formula-line">Final = (P₁×W₁ + P₂×W₂ + P₃×W₃) / ΣW</div>
                  <div class="formula-explainer">
                    <span>P = AI probability</span>
                    <span>W = model weight</span>
                  </div>
                </div>

                <h5>Model Info</h5>
                <ul class="methodology-list">
                  <li><strong>Ateeqq</strong> – 99.23% accuracy, trained on 2024 generators</li>
                  <li><strong>Coverage:</strong> MJ 6.1, Flux 1.1, SD 3.5, DALL-E 3, GPT-4o, Ideogram 2.0</li>
                  <li><strong>Architecture:</strong> SigLIP ViT-B/16 (86M params)</li>
                </ul>
              </div>

              <div class="methodology-column">
                <h5>Interpretation Guide</h5>
                <ul class="methodology-list">
                  <li><strong>≥70%:</strong> High confidence AI-generated</li>
                  <li><strong>30-70%:</strong> Uncertain - may be edited or hybrid</li>
                  <li><strong>≤30%:</strong> Likely human-created</li>
                  <li><strong>Low confidence:</strong> Image may be heavily post-processed</li>
                </ul>

                <h5>Known Limitations</h5>
                <ul class="methodology-list">
                  <li>Generators released after model training may evade detection</li>
                  <li>Heavy post-processing can fool detectors</li>
                  <li>Hybrid content (real + AI elements) challenges classification</li>
                </ul>
              </div>
            </div>
          </div>

          <!-- Image Forensics -->
          <div id="forensicsContainer" class="forensics-container hidden">
            <div class="forensic-divider"><span>Image Forensics</span></div>

            <!-- Metadata -->
            <div class="forensic-subsection">
              <div class="subsection-header" data-target="metadataBody">
                <svg class="chevron" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                <span>Image Properties &amp; Metadata</span>
              </div>
              <div class="subsection-body" id="metadataBody">
                <div id="metadataContent"><p class="forensic-loading">Extracting metadata...</p></div>
              </div>
            </div>

            <!-- Watermark Scan -->
            <div class="forensic-subsection">
              <div class="subsection-header" data-target="watermarkBody">
                <svg class="chevron" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                <span>Watermark Scan</span>
              </div>
              <div class="subsection-body" id="watermarkBody">
                <div id="watermarkContent"><p class="forensic-loading">Scanning for watermarks...</p></div>
              </div>
            </div>

            <!-- Error Level Analysis -->
            <div class="forensic-subsection">
              <div class="subsection-header" data-target="elaBody">
                <svg class="chevron" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                <span>Error Level Analysis</span>
              </div>
              <div class="subsection-body" id="elaBody">
                <div id="elaContent"><p class="forensic-loading">Running ELA...</p></div>
              </div>
            </div>

            <!-- Frequency Spectrum -->
            <div class="forensic-subsection">
              <div class="subsection-header" data-target="spectrumBody">
                <svg class="chevron" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                <span>Frequency Spectrum</span>
              </div>
              <div class="subsection-body" id="spectrumBody">
                <div id="spectrumContent"><p class="forensic-loading">Computing FFT...</p></div>
              </div>
            </div>

            <!-- Technical Details -->
            <div class="forensic-subsection">
              <div class="subsection-header" data-target="techBody">
                <svg class="chevron" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                <span>Technical Details</span>
              </div>
              <div class="subsection-body" id="techBody">
                <div id="techContent"></div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // Conditional logging for production
    const DEBUG = window.location.hostname === 'localhost' || window.location.search.includes('debug=1');
    const logger = {
      log: (...args) => DEBUG && console.log(...args),
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    };

    // PHASE 1: Verify ONNX init ran
    if (!window.__ONNX_RUNTIME_CONFIG__) {
      console.error('[App] ONNX init script did not run! Check script load order.');
    } else {
      logger.log('[App] ONNX runtime config ready:', window.__ONNX_RUNTIME_CONFIG__);
      logger.log('[App] Note: window.ort will be loaded on-demand by InferenceEngine');
    }

    import * as ModelManager from './src/ui/ModelManager.js';
    import * as InferenceEngine from './src/ui/InferenceEngine.js';
    import { stateManager } from './src/ui/StateManager.js';
    import * as DownloadTracker from './src/ui/DownloadTracker.js';
    import { extractMetadata } from './src/forensics/metadata.js';
    import { scanWatermarks } from './src/forensics/watermark.js';
    import { runELA } from './src/forensics/ela.js';
    import { analyzeSpectrum } from './src/forensics/spectrum.js';

    // ========================================
    // State Management (Using StateManager)
    // ========================================

    // Detect iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // Legacy state object for backward compatibility with existing code
    const state = {
      selectedModels: isIOS
        ? new Set(['ateeqq'])  // iOS: Only 1 model to prevent memory crashes
        : new Set(['ateeqq']),  // Single best model - 99.23% accuracy, 2024 training data
      currentImage: null,
      currentImageData: null,
      isAnalyzing: false,
      modelsLoaded: 0,
      modelStatuses: new Map()
    };

    // ========================================
    // DOM Elements
    // ========================================

    const elements = {
      loadingOverlay: document.getElementById('loadingOverlay'),
      loadingSubtext: document.getElementById('loadingSubtext'),
      backendValue: document.getElementById('backendValue'),
      // Model info card elements
      modelStatus: document.getElementById('modelStatus'),
      gpuStatus: document.getElementById('gpuStatus'),
      featureWebGPU: document.getElementById('featureWebGPU'),
      // Legacy model selector elements (may be null)
      fullImageList: document.getElementById('fullImageList'),
      faceManipulationList: document.getElementById('faceManipulationList'),
      fullImageCount: document.getElementById('fullImageCount'),
      faceManipulationCount: document.getElementById('faceManipulationCount'),
      fullImageSelectAll: document.getElementById('fullImageSelectAll'),
      fullImageClear: document.getElementById('fullImageClear'),
      faceManipulationSelectAll: document.getElementById('faceManipulationSelectAll'),
      faceManipulationClear: document.getElementById('faceManipulationClear'),
      uploadZone: document.getElementById('uploadZone'),
      fileInput: document.getElementById('fileInput'),
      previewImage: document.getElementById('previewImage'),
      fileName: document.getElementById('fileName'),
      removeBtn: document.getElementById('removeBtn'),
      analyzeBtn: document.getElementById('analyzeBtn'),
      newAnalysisBtn: document.getElementById('newAnalysisBtn'),
      resultsPanel: document.getElementById('resultsPanel'),
      scanningState: document.getElementById('scanningState'),
      scanningText: document.getElementById('scanningText'),
      scanningSubtext: document.getElementById('scanningSubtext'),
      progressFill: document.getElementById('progressFill'),
      modelProgressList: document.getElementById('modelProgressList'),
      resultsContent: document.getElementById('resultsContent'),
      resultIcon: document.getElementById('resultIcon'),
      resultTitle: document.getElementById('resultTitle'),
      resultSubtitle: document.getElementById('resultSubtitle'),
      confidenceValue: document.getElementById('confidenceValue'),
      totalTime: document.getElementById('totalTime'),
      avgTime: document.getElementById('avgTime'),
      analysisProgress: document.getElementById('analysisProgress'),
      uploadSection: document.getElementById('uploadZone'),
      // Forensic elements
      forensicsContainer: document.getElementById('forensicsContainer'),
      metadataContent: document.getElementById('metadataContent'),
      watermarkContent: document.getElementById('watermarkContent'),
      elaContent: document.getElementById('elaContent'),
      spectrumContent: document.getElementById('spectrumContent'),
      techContent: document.getElementById('techContent'),
    };

    // ========================================
    // Matrix Rain Animation
    // ========================================

    function initMatrixRain() {
      const canvas = document.getElementById('matrixRain');
      // alpha: false = opaque canvas, eliminates iOS Safari compositor flash
      // desynchronized: true = reduces input latency
      const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

      const chars = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
      const fontSize = 14;
      let columns, drops, logicalWidth, logicalHeight;

      function initCanvas() {
        const dpr = window.devicePixelRatio || 1;
        logicalWidth = window.innerWidth;
        logicalHeight = window.innerHeight;

        // Set canvas internal size to account for high-DPI displays
        canvas.width = logicalWidth * dpr;
        canvas.height = logicalHeight * dpr;

        // Set CSS size to fill viewport
        canvas.style.width = logicalWidth + 'px';
        canvas.style.height = logicalHeight + 'px';

        // Scale context to match DPI
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // Fill with solid background (required for alpha: false canvas)
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, logicalWidth, logicalHeight);

        columns = Math.floor(logicalWidth / fontSize);
        drops = Array(columns).fill(1);
      }

      function draw() {
        ctx.fillStyle = 'rgba(10, 10, 15, 0.05)';
        ctx.fillRect(0, 0, logicalWidth, logicalHeight);

        ctx.fillStyle = '#00ff9d';
        ctx.font = `${fontSize}px monospace`;

        for (let i = 0; i < drops.length; i++) {
          const char = chars[Math.floor(Math.random() * chars.length)];
          const x = i * fontSize;
          const y = drops[i] * fontSize;

          ctx.fillText(char, x, y);

          if (y > logicalHeight && Math.random() > 0.975) {
            drops[i] = 0;
          }
          drops[i]++;
        }
      }

      initCanvas();
      setInterval(draw, 33);
    }

    // ========================================
    // Toast Notification (Safe DOM construction)
    // ========================================

    function showUpdateNotification(onAccept) {
      const toast = document.createElement('div');
      toast.className = 'update-toast';
      const content = document.createElement('div');
      content.className = 'toast-content';
      const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      icon.setAttribute('width', '20');
      icon.setAttribute('height', '20');
      icon.setAttribute('viewBox', '0 0 24 24');
      icon.setAttribute('fill', 'none');
      icon.setAttribute('stroke', 'currentColor');
      icon.setAttribute('stroke-width', '2');
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', '12');
      circle.setAttribute('cy', '12');
      circle.setAttribute('r', '10');
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', 'M12 16v-4M12 8h.01');
      icon.appendChild(circle);
      icon.appendChild(path);
      const text = document.createElement('span');
      text.textContent = 'New version available!';
      content.appendChild(icon);
      content.appendChild(text);
      const actions = document.createElement('div');
      actions.className = 'toast-actions';
      const reloadBtn = document.createElement('button');
      reloadBtn.className = 'toast-btn toast-reload';
      reloadBtn.textContent = 'Reload';
      const dismissBtn = document.createElement('button');
      dismissBtn.className = 'toast-btn toast-dismiss';
      dismissBtn.textContent = 'Later';
      actions.appendChild(reloadBtn);
      actions.appendChild(dismissBtn);
      toast.appendChild(content);
      toast.appendChild(actions);
      document.body.appendChild(toast);
      setTimeout(() => toast.classList.add('show'), 10);
      reloadBtn.addEventListener('click', () => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
        onAccept();
      });
      dismissBtn.addEventListener('click', () => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
      });
      setTimeout(() => {
        if (document.body.contains(toast)) {
          toast.classList.remove('show');
          setTimeout(() => toast.remove(), 300);
        }
      }, 30000);
    }

    // ========================================
    // Backend Detection
    // ========================================

    function updateBackendIndicator(backend) {
      // Update header backend indicator
      if (backend === 'webgpu') {
        elements.backendValue.textContent = 'WebGPU (GPU Accelerated)';
        elements.backendValue.className = 'backend-value webgpu';
      } else if (backend === 'wasm') {
        elements.backendValue.textContent = 'WASM (CPU)';
        elements.backendValue.className = 'backend-value wasm';
      } else if (backend === 'cpu') {
        elements.backendValue.textContent = 'CPU (Software Fallback)';
        elements.backendValue.className = 'backend-value cpu';
      } else {
        elements.backendValue.textContent = 'Unknown';
        elements.backendValue.className = 'backend-value';
      }

      // Update model info card GPU status
      if (elements.gpuStatus) {
        if (backend === 'webgpu') {
          elements.gpuStatus.textContent = 'GPU Active';
          elements.featureWebGPU?.querySelector('.feature-icon')?.classList.add('active');
        } else if (backend === 'wasm') {
          elements.gpuStatus.textContent = 'CPU (WASM)';
        } else {
          elements.gpuStatus.textContent = 'CPU Fallback';
        }
      }
    }

    function updateModelCardStatus(status, text) {
      if (!elements.modelStatus) return;
      const statusText = elements.modelStatus.querySelector('.status-text');
      if (statusText) statusText.textContent = text || status;
      elements.modelStatus.className = 'model-info-status ' + status;
    }

    // ========================================
    // Model Category Rendering
    // ========================================

    function renderModelCategories() {
      renderCategory('FULL_IMAGE_DETECTORS', elements.fullImageList);
      // Face manipulation section is disabled - no models available
      if (elements.faceManipulationList) {
        renderCategory('FACE_MANIPULATION_DETECTORS', elements.faceManipulationList);
      }
      updateCategoryCounts();
    }

    function renderCategory(category, container) {
      if (!container) return;
      container.replaceChildren();
      const models = ModelManager.getModelsByCategory(category);
      // Filter out disabled models
      models.filter(model => !model.disabled).forEach(model => {
        const div = document.createElement('div');
        div.className = 'model-item';
        div.id = 'model-' + model.id;

        // Create model label with name and accuracy
        const label = document.createElement('span');
        label.className = 'model-label';
        label.textContent = model.displayName + ' (' + (model.accuracy || '~95%') + ')';
        div.appendChild(label);

        // Add training info badge
        if (model.trainedOn) {
          const badge = document.createElement('span');
          badge.className = 'model-training-badge';
          badge.textContent = model.trainedOn;
          badge.title = 'Trained on: ' + model.trainedOn;
          div.appendChild(badge);
        }

        if (state.selectedModels.has(model.id)) div.classList.add('selected');
        div.onclick = () => toggleModelSelection(model.id);
        container.appendChild(div);
      });
    }

    function toggleModelSelection(modelId) {
      if (state.isAnalyzing) return;
      state.selectedModels.has(modelId) ? state.selectedModels.delete(modelId) : state.selectedModels.add(modelId);
      document.getElementById('model-' + modelId)?.classList.toggle('selected');
      updateCategoryCounts();
      updateAnalyzeButton();
    }

    function updateCategoryCounts() {
      // Filter out disabled models from counts
      const fullImageModels = ModelManager.getModelsByCategory('FULL_IMAGE_DETECTORS').filter(m => !m.disabled);
      const fullImageSelected = fullImageModels.filter(m => state.selectedModels.has(m.id)).length;
      if (elements.fullImageCount) {
        elements.fullImageCount.textContent = `${fullImageSelected}/${fullImageModels.length}`;
      }
      // Face manipulation section is disabled
      if (elements.faceManipulationCount) {
        const faceModels = ModelManager.getModelsByCategory('FACE_MANIPULATION_DETECTORS').filter(m => !m.disabled);
        const faceSelected = faceModels.filter(m => state.selectedModels.has(m.id)).length;
        elements.faceManipulationCount.textContent = `${faceSelected}/${faceModels.length}`;
      }
    }

    function updateModelStatus(modelId, status) {
      const modelEl = document.getElementById('model-' + modelId);
      if (modelEl) {
        modelEl.classList.remove('loading', 'ready', 'error', 'pending');
        modelEl.classList.add(status);
      }
    }

    // ========================================
    // Image Upload Handling
    // ========================================

    function setupUploadHandlers() {
      // File input change
      elements.fileInput.addEventListener('change', (e) => {
        if (e.target.files.length) {
          handleFile(e.target.files[0]);
        }
      });

      // Drag and drop
      elements.uploadZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        elements.uploadZone.classList.add('dragover');
      });

      elements.uploadZone.addEventListener('dragleave', () => {
        elements.uploadZone.classList.remove('dragover');
      });

      elements.uploadZone.addEventListener('drop', (e) => {
        e.preventDefault();
        elements.uploadZone.classList.remove('dragover');
        if (e.dataTransfer.files.length) {
          handleFile(e.dataTransfer.files[0]);
        }
      });

      // Remove button
      elements.removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        clearUploadedImage();
      });
    }

    // ========================================
    // Clipboard Paste Support (Issue #4)
    // ========================================

    function setupClipboardPaste() {
      document.addEventListener('paste', async (event) => {
        const items = event.clipboardData?.items;
        if (!items) return;

        for (const item of items) {
          if (item.type.startsWith('image/')) {
            event.preventDefault();

            const blob = item.getAsFile();
            if (!blob) continue;

            // Create object URL for preview
            const imageUrl = URL.createObjectURL(blob);

            // Handle the file
            handlePastedFile(blob, imageUrl);

            logger.log('[Clipboard] Image pasted from clipboard');
            break;
          }
        }
      });

      // Visual hint when hovering over upload zone
      elements.uploadZone.addEventListener('focusin', () => {
        if (!elements.uploadZone.classList.contains('has-image')) {
          elements.uploadZone.setAttribute('data-hint', 'Tip: You can paste images directly (Ctrl+V or Cmd+V)');
        }
      });
    }

    function handlePastedFile(blob, imageUrl) {
      state.currentImage = blob;
      state.currentImageData = imageUrl;
      elements.previewImage.src = imageUrl;
      elements.fileName.textContent = 'pasted-image.png';
      elements.uploadZone.classList.add('has-image');
      resetResults();
      updateAnalyzeButton();
    }

    async function handleFile(file) {
      if (!file.type.startsWith('image/')) return;

      // Use blob URL instead of data URL to avoid memory issues
      // Data URLs can be 60-90MB for large images, blob URLs are instant
      const blobUrl = URL.createObjectURL(file);

      state.currentImage = file;
      state.currentImageData = blobUrl;
      elements.previewImage.src = blobUrl;
      elements.fileName.textContent = file.name;
      elements.uploadZone.classList.add('has-image');
      resetResults();
      updateAnalyzeButton();

      // Persist to IndexedDB for crash recovery
      stateManager.setImage(blobUrl, file);
      stateManager.persistImage();
    }

    // Restore persisted image on load
    async function restorePersistedImage() {
      const restored = await stateManager.restoreImage();
      if (restored) {
        state.currentImageData = restored.url;
        elements.previewImage.src = restored.url;
        elements.fileName.textContent = 'Restored image';
        elements.uploadZone.classList.add('has-image');
        updateAnalyzeButton();
        console.log('[App] Restored image from previous session');
      }
    }

    function clearUploadedImage() {
      // Revoke blob URL to free memory
      if (state.currentImageData && state.currentImageData.startsWith('blob:')) {
        URL.revokeObjectURL(state.currentImageData);
      }

      elements.uploadZone.classList.remove('has-image');
      elements.fileInput.value = '';
      elements.previewImage.src = '';
      state.currentImage = null;
      state.currentImageData = null;
      resetResults();
      updateAnalyzeButton();
    }

    function resetResults() {
      elements.resultsPanel.classList.remove('active', 'success', 'warning', 'danger', 'mixed');
      elements.scanningState.classList.remove('hidden');
      elements.resultsContent.classList.add('hidden');
      // Reset forensics
      if (elements.forensicsContainer) {
        elements.forensicsContainer.classList.add('hidden');
        elements.metadataContent.innerHTML = '<p class="forensic-loading">Extracting metadata...</p>';
        elements.watermarkContent.innerHTML = '<p class="forensic-loading">Scanning for watermarks...</p>';
        elements.elaContent.innerHTML = '<p class="forensic-loading">Running ELA...</p>';
        elements.spectrumContent.innerHTML = '<p class="forensic-loading">Computing FFT...</p>';
        elements.techContent.innerHTML = '';
      }
    }

    // ========================================
    // Analyze Button
    // ========================================

    function updateAnalyzeButton() {
      const hasImage = state.currentImage !== null;
      const hasSelectedModels = state.selectedModels && state.selectedModels.size > 0;
      const canAnalyze = hasImage && hasSelectedModels && !state.isAnalyzing;

      elements.analyzeBtn.disabled = !canAnalyze;

      if (canAnalyze) {
        elements.analyzeBtn.classList.add('ready');
        elements.analyzeBtn.querySelector('.btn-text').textContent = 'Analyze Image';
      } else if (!hasSelectedModels) {
        elements.analyzeBtn.classList.remove('ready');
        elements.analyzeBtn.querySelector('.btn-text').textContent = 'Select at least one model';
      } else if (!hasImage) {
        elements.analyzeBtn.classList.remove('ready');
        elements.analyzeBtn.querySelector('.btn-text').textContent = 'Upload an image to analyze';
      }
    }

    function setupAnalyzeButton() {
      elements.analyzeBtn.addEventListener('click', async () => {
        if (!elements.analyzeBtn.disabled) {
          await runAnalysis();
        }
      });
    }

    // ========================================
    // New Analysis Button Handler (Issue #2)
    // ========================================

    function setupNewAnalysisButton() {
      elements.newAnalysisBtn.addEventListener('click', () => {
        // Clear uploaded image
        clearUploadedImage();

        // Hide results panel and new analysis button
        elements.resultsPanel.classList.remove('active', 'success', 'warning', 'danger', 'mixed');
        elements.scanningState.classList.remove('hidden');
        elements.resultsContent.classList.add('hidden');
        elements.newAnalysisBtn.style.display = 'none';

        // Scroll back to upload zone
        elements.uploadSection.scrollIntoView({ behavior: 'smooth' });

        logger.log('[UI] New analysis started');
      });
    }

    // ========================================
    // Clear Cache Button
    // ========================================

    function setupClearCacheButton() {
      const btn = document.getElementById('clearCacheBtn');
      if (!btn) return;

      btn.addEventListener('click', async () => {
        if (!confirm('Clear all cached data and reload? This will require re-downloading models.')) {
          return;
        }

        btn.textContent = 'Clearing...';
        btn.disabled = true;

        try {
          // Clear Service Worker caches
          if ('caches' in window) {
            const cacheNames = await caches.keys();
            await Promise.all(cacheNames.map(name => caches.delete(name)));
            console.log('[ClearCache] SW caches cleared');
          }

          // Clear IndexedDB (model cache)
          const databases = await indexedDB.databases?.() || [];
          for (const db of databases) {
            if (db.name) {
              indexedDB.deleteDatabase(db.name);
              console.log('[ClearCache] Deleted IndexedDB:', db.name);
            }
          }

          // Clear localStorage
          localStorage.clear();
          console.log('[ClearCache] localStorage cleared');

          // Unregister service workers
          if ('serviceWorker' in navigator) {
            const registrations = await navigator.serviceWorker.getRegistrations();
            for (const reg of registrations) {
              await reg.unregister();
              console.log('[ClearCache] SW unregistered');
            }
          }

          // Reload page
          window.location.reload(true);

        } catch (error) {
          console.error('[ClearCache] Error:', error);
          btn.textContent = 'Error!';
          setTimeout(() => {
            btn.textContent = 'Clear Cache';
            btn.disabled = false;
          }, 2000);
        }
      });
    }

    // ========================================
    // Analysis Execution
    // ========================================

    async function runAnalysis() {
      if (!state.currentImageData || state.modelsLoaded === 0) return;

      state.isAnalyzing = true;
      elements.analyzeBtn.classList.remove('ready');
      elements.analyzeBtn.classList.add('scanning');
      elements.analyzeBtn.disabled = true;
      elements.analyzeBtn.querySelector('.btn-text').textContent = 'Analyzing...';

      elements.resultsPanel.classList.add('active');
      elements.scanningState.classList.remove('hidden');
      elements.resultsContent.classList.add('hidden');
      elements.newAnalysisBtn.style.display = 'none';

      const votes = [];
      const weightedScores = []; // {score, weight, confidence}
      const startTime = performance.now();

      // Model weights for ensemble calculation
      // Weights based on: accuracy + training data recency + concept drift
      const ENSEMBLE_WEIGHTS = {
        'ateeqq': 1.5,          // 99.23% accurate, 2024 training data (latest)
        'dima806_ai_real': 0.8  // 98.2% accurate BUT ~2yr old, concept drift (lower weight)
        // Note: prithiv_v2 removed - low confidence, overlaps with others
        // Note: smogy removed - fails on ChatGPT/DALL-E 3 images (trained on older generators)
      };
      const totalModels = state.selectedModels.size;
      const modelIds = Array.from(state.selectedModels);

      // Build per-model progress UI
      elements.modelProgressList.textContent = '';
      const progressBars = {};

      modelIds.forEach(modelId => {
        const modelInfo = ModelManager.getModelInfo(modelId);
        const displayName = modelInfo ? modelInfo.displayName : modelId;

        const item = document.createElement('div');
        item.className = 'model-progress-item';

        const name = document.createElement('span');
        name.className = 'model-progress-name';
        name.textContent = displayName.length > 16 ? displayName.substring(0, 14) + '...' : displayName;
        name.title = displayName;

        const bar = document.createElement('div');
        bar.className = 'model-progress-bar';

        const fill = document.createElement('div');
        fill.className = 'model-progress-fill';
        fill.style.width = '0%';

        const status = document.createElement('span');
        status.className = 'model-progress-status';
        status.textContent = 'waiting';

        bar.appendChild(fill);
        item.appendChild(name);
        item.appendChild(bar);
        item.appendChild(status);
        elements.modelProgressList.appendChild(item);

        progressBars[modelId] = { fill, status, item };
      });

      // Helper to get preliminary result info
      function getPreliminaryInfo(avgScore) {
        if (avgScore >= 70) return { label: 'AI Generated', color: 'var(--danger)' };
        if (avgScore >= 55) return { label: 'Likely AI', color: 'var(--warning)' };
        if (avgScore <= 30) return { label: 'Likely Real', color: 'var(--success)' };
        return { label: 'Analyzing...', color: 'var(--cyan)' };
      }

      // Helper to update preliminary results
      function updatePreliminaryResult(completedCount) {
        if (weightedScores.length === 0) {
          elements.scanningSubtext.textContent = 'Loading models...';
          return;
        }
        // Simple average for preliminary display (full weighted calc at end)
        const avgScore = weightedScores.reduce((sum, ws) => sum + ws.score, 0) / weightedScores.length;
        const pct = Math.round(avgScore);
        const info = getPreliminaryInfo(avgScore);

        elements.scanningSubtext.textContent = '';
        const line1 = document.createElement('span');
        line1.style.color = info.color;
        line1.style.fontWeight = '600';
        line1.textContent = pct + '% AI - ' + info.label;
        elements.scanningSubtext.appendChild(line1);

        elements.progressFill.style.width = (completedCount / totalModels * 100) + '%';
      }

      try {
        // currentImageData is either a blob URL or the original File/Blob
        const imageBlob = state.currentImage instanceof Blob
          ? state.currentImage
          : await fetch(state.currentImageData).then(r => r.blob());
        let completedCount = 0;

        for (const modelId of modelIds) {
          const modelInfo = ModelManager.getModelInfo(modelId);
          if (!modelInfo) continue;

          const pb = progressBars[modelId];
          pb.fill.className = 'model-progress-fill running';
          pb.status.textContent = 'loading';
          pb.status.className = 'model-progress-status';

          // Subscribe to real-time download progress
          const unsubscribe = DownloadTracker.subscribe(modelId, (percent, status) => {
            if (status === 'downloading') {
              pb.fill.style.width = (percent * 0.8) + '%'; // 0-80% for download
              pb.status.textContent = percent + '%';
            } else if (status === 'cached') {
              pb.fill.style.width = '80%';
              pb.status.textContent = 'cached';
              pb.status.className = 'model-progress-status cached';
            }
          });

          try {
            const modelStart = performance.now();

            // Update to running state
            pb.fill.style.width = '80%';
            pb.status.textContent = 'running';

            // Run inference - the model's load() will emit download progress
            const results = await InferenceEngine.runInference(imageBlob, [modelId], {});

            // Cleanup subscription
            unsubscribe();

            const modelTime = performance.now() - modelStart;
            const modelResult = results.modelResults[0];

            if (modelResult && !modelResult.error) {
              const aiScore = modelResult.aiProbability;
              const confidence = modelResult.confidence || 50; // Default 50% if not provided
              const weight = ENSEMBLE_WEIGHTS[modelId] || 1.0;
              weightedScores.push({ modelId, score: aiScore, weight, confidence });

              let vote = 'unsure';
              if (aiScore >= 65) vote = 'ai';
              else if (aiScore <= 35) vote = 'human';

              votes.push({
                modelId: modelId,
                model: modelInfo.displayName,
                vote: vote,
                score: Math.round(aiScore),
                time: Math.round(modelTime),
                fullResult: modelResult
              });

              pb.fill.style.width = '100%';
              pb.fill.className = 'model-progress-fill complete';
              pb.status.textContent = Math.round(aiScore) + '%';
              pb.status.className = 'model-progress-status complete';
            } else {
              throw new Error(modelResult?.error || 'Unknown error');
            }
          } catch (err) {
            unsubscribe();
            console.error('Error with ' + modelInfo.displayName + ':', err);
            votes.push({ model: modelInfo.displayName, vote: 'error', score: 0, time: 0 });
            pb.fill.style.width = '100%';
            pb.fill.className = 'model-progress-fill error';
            pb.status.textContent = 'error';
            pb.status.className = 'model-progress-status';
          }

          completedCount++;
          updatePreliminaryResult(completedCount);
        }

        const totalTime = performance.now() - startTime;

        // Single model - use score directly (no ensemble math needed)
        const avgScore = weightedScores.length > 0 ? weightedScores[0].score : 50;
        const modelConf = weightedScores.length > 0 ? weightedScores[0].confidence : 0;
        console.log(`[Detection] Ateeqq result: ${avgScore.toFixed(1)}% AI (confidence: ${modelConf.toFixed(1)}%)`);
        showResults(avgScore, votes, totalTime);

        // Run forensic analysis in parallel (non-blocking)
        runForensicAnalysis(imageBlob);

      } catch (error) {
        console.error('Analysis failed:', error);
        showError(error.message);
      } finally {
        state.isAnalyzing = false;
        elements.analyzeBtn.classList.remove('scanning');
        elements.analyzeBtn.classList.add('ready');
        elements.analyzeBtn.disabled = false;
        elements.analyzeBtn.querySelector('.btn-text').textContent = 'Analyze Again';

        // Show new analysis button after results
        elements.newAnalysisBtn.style.display = 'block';
      }
    }

    // ========================================
    // Forensic Analysis
    // ========================================

    function escapeHTML(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    async function runForensicAnalysis(imageBlob) {
      if (!elements.forensicsContainer) return;
      elements.forensicsContainer.classList.remove('hidden');

      // Display tech details immediately (no async needed)
      displayTechDetails();

      // Run all forensic modules in parallel
      const [metaResult, wmResult, elaResult, specResult] = await Promise.allSettled([
        extractMetadata(imageBlob),
        scanWatermarks(imageBlob),
        runELA(imageBlob),
        analyzeSpectrum(imageBlob),
      ]);

      if (metaResult.status === 'fulfilled') {
        displayMetadata(metaResult.value);
      } else {
        elements.metadataContent.innerHTML = '<p class="forensic-error">Metadata extraction failed: ' + escapeHTML(metaResult.reason?.message || 'Unknown error') + '</p>';
      }

      if (wmResult.status === 'fulfilled') {
        displayWatermarks(wmResult.value);
      } else {
        elements.watermarkContent.innerHTML = '<p class="forensic-error">Watermark scan failed: ' + escapeHTML(wmResult.reason?.message || 'Unknown error') + '</p>';
      }

      if (elaResult.status === 'fulfilled') {
        displayELA(elaResult.value);
      } else {
        elements.elaContent.innerHTML = '<p class="forensic-error">ELA failed: ' + escapeHTML(elaResult.reason?.message || 'Unknown error') + '</p>';
      }

      if (specResult.status === 'fulfilled') {
        displaySpectrum(specResult.value);
      } else {
        elements.spectrumContent.innerHTML = '<p class="forensic-error">Spectrum analysis failed: ' + escapeHTML(specResult.reason?.message || 'Unknown error') + '</p>';
      }
    }

    function displayMetadata(data) {
      let html = '';

      // Properties table
      if (data.properties && Object.keys(data.properties).length > 0) {
        html += '<h5 class="forensic-table-title">File Properties</h5>';
        html += '<table class="forensic-table"><tbody>';
        for (const [key, val] of Object.entries(data.properties)) {
          html += '<tr><td class="forensic-table-label">' + escapeHTML(key) + '</td><td class="forensic-table-value">' + escapeHTML(String(val)) + '</td></tr>';
        }
        html += '</tbody></table>';
      }

      // EXIF data
      if (data.exif && Object.keys(data.exif).length > 0) {
        html += '<h5 class="forensic-table-title">EXIF Data</h5>';
        html += '<table class="forensic-table"><tbody>';
        for (const [key, val] of Object.entries(data.exif)) {
          html += '<tr><td class="forensic-table-label">' + escapeHTML(key) + '</td><td class="forensic-table-value-mono">' + escapeHTML(String(val)) + '</td></tr>';
        }
        html += '</tbody></table>';
      }

      // PNG text chunks
      if (data.pngText && Object.keys(data.pngText).length > 0) {
        html += '<h5 class="forensic-table-title">PNG Text Chunks</h5>';
        html += '<table class="forensic-table"><tbody>';
        for (const [key, val] of Object.entries(data.pngText)) {
          const display = String(val).length > 200 ? String(val).substring(0, 200) + '...' : String(val);
          html += '<tr><td class="forensic-table-label">' + escapeHTML(key) + '</td><td class="forensic-table-value-mono">' + escapeHTML(display) + '</td></tr>';
        }
        html += '</tbody></table>';
      }

      // AI markers
      if (data.aiMarkers && data.aiMarkers.length > 0) {
        html += '<h5 class="forensic-table-title">AI Generation Markers</h5>';
        html += '<div class="ai-markers-list">';
        for (const marker of data.aiMarkers) {
          html += '<div class="ai-marker-flag">' + escapeHTML(marker) + '</div>';
        }
        html += '</div>';
      }

      // C2PA
      if (data.c2pa) {
        html += '<h5 class="forensic-table-title">Content Credentials (C2PA)</h5>';
        html += '<div class="ai-marker-flag">' + escapeHTML(data.c2pa) + '</div>';
      }

      if (!html) {
        html = '<p class="forensic-empty">No metadata found in this image.</p>';
      }

      elements.metadataContent.innerHTML = html;
    }

    function displayWatermarks(data) {
      if (!data.detected) {
        elements.watermarkContent.innerHTML = '<p class="forensic-empty">No visible watermarks detected.</p>';
        return;
      }

      let html = '<div class="watermark-results">';
      for (const wm of data.watermarks) {
        const confPct = Math.round(wm.confidence * 100);
        html += '<div class="watermark-badge">';
        html += '<span class="watermark-generator">' + escapeHTML(wm.generator) + '</span>';
        html += '<span class="watermark-confidence">' + confPct + '% confidence</span>';
        html += '<span class="watermark-region">' + escapeHTML(wm.region) + '</span>';
        html += '</div>';
      }
      html += '</div>';
      elements.watermarkContent.innerHTML = html;
    }

    function displayELA(data) {
      let html = '';

      // Canvas for heatmap
      html += '<canvas id="elaCanvas" class="forensic-canvas"></canvas>';

      // Stats grid
      html += '<div class="forensic-stats">';
      html += '<div class="stat-item"><span class="stat-label">Mean Error</span><span class="stat-value">' + data.stats.mean + '</span></div>';
      html += '<div class="stat-item"><span class="stat-label">Std Dev</span><span class="stat-value">' + data.stats.stdDev + '</span></div>';
      html += '<div class="stat-item"><span class="stat-label">Entropy</span><span class="stat-value">' + data.stats.entropy + '</span></div>';
      html += '<div class="stat-item"><span class="stat-label">Uniformity</span><span class="stat-value">' + data.stats.spatialUniformity + '</span></div>';
      html += '<div class="stat-item"><span class="stat-label">CV</span><span class="stat-value">' + data.stats.coefficientOfVariation + '</span></div>';
      html += '<div class="stat-item"><span class="stat-label">Range</span><span class="stat-value">' + data.stats.min + ' - ' + data.stats.max + '</span></div>';
      html += '</div>';

      // Interpretation
      html += '<p class="forensic-interpretation">' + escapeHTML(data.interpretation) + '</p>';

      elements.elaContent.innerHTML = html;

      // Render heatmap to canvas
      const canvas = document.getElementById('elaCanvas');
      if (canvas && data.heatmapImageData) {
        canvas.width = data.width;
        canvas.height = data.height;
        const ctx = canvas.getContext('2d');
        ctx.putImageData(data.heatmapImageData, 0, 0);
      }
    }

    function displaySpectrum(data) {
      let html = '';

      // Canvas for spectrum
      html += '<canvas id="spectrumCanvas" class="forensic-canvas"></canvas>';

      // Features grid
      html += '<div class="forensic-stats">';
      html += '<div class="stat-item"><span class="stat-label">Spectral Flatness</span><span class="stat-value">' + data.features.spectralFlatness + '</span></div>';
      html += '<div class="stat-item"><span class="stat-label">Energy Concentration</span><span class="stat-value">' + data.features.energyConcentration + '</span></div>';
      html += '<div class="stat-item"><span class="stat-label">High-Freq Ratio</span><span class="stat-value">' + data.features.highFreqRatio + '</span></div>';
      html += '<div class="stat-item"><span class="stat-label">Spectral Slope</span><span class="stat-value">' + data.features.spectralSlope + '</span></div>';
      html += '<div class="stat-item"><span class="stat-label">Periodic Spikes</span><span class="stat-value">' + data.features.periodicSpikes + '</span></div>';
      html += '</div>';

      // Interpretation
      html += '<p class="forensic-interpretation">' + escapeHTML(data.interpretation) + '</p>';

      elements.spectrumContent.innerHTML = html;

      // Render spectrum to canvas
      const canvas = document.getElementById('spectrumCanvas');
      if (canvas && data.spectrumImageData) {
        canvas.width = data.width;
        canvas.height = data.height;
        const ctx = canvas.getContext('2d');
        ctx.putImageData(data.spectrumImageData, 0, 0);
      }
    }

    async function displayTechDetails() {
      let html = '<table class="forensic-table"><tbody>';
      const backend = InferenceEngine.getBackend ? InferenceEngine.getBackend() : 'unknown';
      html += '<tr><td class="forensic-table-label">Inference Backend</td><td class="forensic-table-value-mono">' + escapeHTML(String(backend)) + '</td></tr>';

      // Try to get GPU info from WebGPU API
      try {
        if (navigator.gpu) {
          const adapter = await navigator.gpu.requestAdapter();
          if (adapter) {
            const info = adapter.info || {};
            if (info.vendor) html += '<tr><td class="forensic-table-label">GPU Vendor</td><td class="forensic-table-value-mono">' + escapeHTML(info.vendor) + '</td></tr>';
            if (info.architecture) html += '<tr><td class="forensic-table-label">GPU Architecture</td><td class="forensic-table-value-mono">' + escapeHTML(info.architecture) + '</td></tr>';
            if (info.device) html += '<tr><td class="forensic-table-label">GPU Device</td><td class="forensic-table-value-mono">' + escapeHTML(info.device) + '</td></tr>';
            if (info.description) html += '<tr><td class="forensic-table-label">GPU Description</td><td class="forensic-table-value-mono">' + escapeHTML(info.description) + '</td></tr>';
          }
        }
      } catch (e) { /* GPU info unavailable */ }

      html += '<tr><td class="forensic-table-label">WASM SIMD</td><td class="forensic-table-value-mono">' + (typeof WebAssembly !== 'undefined' ? 'Supported' : 'No') + '</td></tr>';
      html += '<tr><td class="forensic-table-label">Hardware Concurrency</td><td class="forensic-table-value-mono">' + (navigator.hardwareConcurrency || 'unknown') + ' threads</td></tr>';
      html += '<tr><td class="forensic-table-label">User Agent</td><td class="forensic-table-value-mono" style="word-break:break-all;font-size:0.7rem">' + escapeHTML(navigator.userAgent) + '</td></tr>';
      html += '</tbody></table>';

      elements.techContent.innerHTML = html;
    }

    function setupCollapsibleSections() {
      document.querySelectorAll('.subsection-header').forEach(header => {
        header.addEventListener('click', () => {
          const targetId = header.getAttribute('data-target');
          const body = document.getElementById(targetId);
          if (!body) return;
          const isOpen = body.classList.contains('open');
          body.classList.toggle('open', !isOpen);
          header.classList.toggle('expanded', !isOpen);
        });
      });
    }

    // ========================================
    // Results Display
    // ========================================

    function showResults(avgScore, votes, totalTime) {
      elements.scanningState.classList.add('hidden');
      elements.resultsContent.classList.remove('hidden');

      let title, subtitle, resultType, iconColor;

      // avgScore is already a percentage (0-100), not decimal (0-1)
      if (avgScore >= 70) {
        title = 'AI Generated';
        subtitle = 'High confidence detection across models';
        resultType = 'danger';
        iconColor = 'var(--danger)';
      } else if (avgScore >= 55) {
        title = 'Likely AI Generated';
        subtitle = 'Multiple models flagged this image';
        resultType = 'warning';
        iconColor = 'var(--warning)';
      } else if (avgScore <= 30) {
        title = 'Likely Human Created';
        subtitle = 'No significant AI markers detected';
        resultType = 'success';
        iconColor = 'var(--success)';
      } else if (avgScore <= 45) {
        title = 'Probably Human Created';
        subtitle = 'Most models see authentic content';
        resultType = 'success';
        iconColor = 'var(--success)';
      } else {
        title = 'Inconclusive';
        subtitle = 'Models disagree on this image';
        resultType = 'mixed';
        iconColor = 'var(--cyan)';
      }

      elements.resultsPanel.className = 'results-panel active ' + resultType;
      elements.resultIcon.style.stroke = iconColor;
      elements.resultTitle.textContent = title;
      elements.resultSubtitle.textContent = subtitle;

      // avgScore is already a percentage (0-100), not a decimal (0-1)
      // Models return aiProbability as percentage, so no need to multiply by 100
      const confidence = Math.round(Math.max(avgScore, 100 - avgScore));
      elements.confidenceValue.textContent = confidence + '%';

      // Update probability meter
      const probabilityFill = document.getElementById('probabilityFill');
      const probabilityMarker = document.getElementById('probabilityMarker');
      const probabilityMarkerValue = document.getElementById('probabilityMarkerValue');

      if (probabilityFill && probabilityMarker && probabilityMarkerValue) {
        probabilityFill.style.width = avgScore + '%';
        probabilityMarker.style.left = avgScore + '%';
        probabilityMarkerValue.textContent = Math.round(avgScore) + '%';

        // Color the fill based on verdict
        if (resultType === 'danger') {
          probabilityFill.style.background = 'linear-gradient(90deg, rgba(239, 68, 68, 0.3), var(--danger))';
        } else if (resultType === 'warning') {
          probabilityFill.style.background = 'linear-gradient(90deg, rgba(245, 158, 11, 0.3), var(--warning))';
        } else if (resultType === 'success') {
          probabilityFill.style.background = 'linear-gradient(90deg, var(--success), rgba(34, 197, 94, 0.3))';
        } else {
          probabilityFill.style.background = 'linear-gradient(90deg, rgba(34, 211, 238, 0.3), var(--cyan))';
        }
      }

      // Populate model cards with detailed predictions
      populateModelCards(votes);

      elements.totalTime.textContent = Math.round(totalTime) + 'ms';
      elements.avgTime.textContent = votes.length > 0 ? Math.round(totalTime / votes.length) + 'ms' : '--';
    }

    function showError(message) {
      elements.scanningState.classList.add('hidden');
      elements.resultsContent.classList.remove('hidden');
      elements.resultsPanel.className = 'results-panel active danger';
      elements.resultIcon.style.stroke = 'var(--danger)';
      elements.resultTitle.textContent = 'Analysis Error';
      elements.resultSubtitle.textContent = message;
      elements.confidenceValue.textContent = '--';

      // Clear model cards
      const modelCards = document.getElementById('modelCards');
      if (modelCards) modelCards.replaceChildren();
    }

    // Model weights for display (matches ENSEMBLE_WEIGHTS)
    const MODEL_WEIGHTS = {
      'ateeqq': 1.5,          // 99.23% accurate, 2024 training data (latest)
      'dima806_ai_real': 0.8  // 98.2% accurate BUT ~2yr old, concept drift
    };

    function populateModelCards(votes) {
      const modelCards = document.getElementById('modelCards');
      modelCards.replaceChildren();

      votes.forEach(v => {
        if (v.vote === 'error' || !v.fullResult) return;

        const weight = MODEL_WEIGHTS[v.modelId] || 1.0;

        // Get metadata from ModelManager (single source of truth)
        const modelInfo = ModelManager.getModelInfo(v.modelId);
        const metadata = {
          accuracy: modelInfo?.accuracy || 'N/A',
          architecture: modelInfo?.architecture || 'Unknown',
          trainingData: modelInfo?.trainedOn || 'Unknown'
        };

        const humanProb = 100 - v.score;
        const aiProb = v.score;

        const card = document.createElement('div');
        card.className = 'model-card';

        // Determine verdict class
        let verdictClass = 'unsure';
        let verdictLabel = 'Unsure';
        if (v.vote === 'ai') {
          verdictClass = 'ai';
          verdictLabel = 'AI Generated';
        } else if (v.vote === 'human') {
          verdictClass = 'human';
          verdictLabel = 'Human Created';
        }

        // Build card using DOM API (XSS-safe)
        const header = document.createElement('div');
        header.className = 'model-card-header';

        const title = document.createElement('div');
        title.className = 'model-card-title';

        const modelName = document.createElement('span');
        modelName.className = 'model-name';
        modelName.textContent = v.model;

        const modelWeight = document.createElement('span');
        modelWeight.className = 'model-weight';
        modelWeight.textContent = `Weight: ${weight}×`;

        title.appendChild(modelName);
        title.appendChild(modelWeight);

        const verdict = document.createElement('div');
        verdict.className = `model-verdict ${verdictClass}`;
        verdict.textContent = verdictLabel;

        header.appendChild(title);
        header.appendChild(verdict);

        // Card body
        const body = document.createElement('div');
        body.className = 'model-card-body';

        // Probability bars
        const probBars = document.createElement('div');
        probBars.className = 'probability-bars';

        // AI probability bar
        const aiBarItem = document.createElement('div');
        aiBarItem.className = 'probability-bar-item';

        const aiLabel = document.createElement('div');
        aiLabel.className = 'prob-bar-label';
        aiLabel.innerHTML = '<span>AI Probability</span>';

        const aiValue = document.createElement('span');
        aiValue.className = 'prob-value';
        aiValue.textContent = `${aiProb.toFixed(1)}%`;
        aiLabel.appendChild(aiValue);

        const aiTrack = document.createElement('div');
        aiTrack.className = 'prob-bar-track';

        const aiFill = document.createElement('div');
        aiFill.className = 'prob-bar-fill ai';
        aiFill.style.width = `${aiProb}%`;
        aiTrack.appendChild(aiFill);

        aiBarItem.appendChild(aiLabel);
        aiBarItem.appendChild(aiTrack);

        // Human probability bar
        const humanBarItem = document.createElement('div');
        humanBarItem.className = 'probability-bar-item';

        const humanLabel = document.createElement('div');
        humanLabel.className = 'prob-bar-label';
        humanLabel.innerHTML = '<span>Human Probability</span>';

        const humanValue = document.createElement('span');
        humanValue.className = 'prob-value';
        humanValue.textContent = `${humanProb.toFixed(1)}%`;
        humanLabel.appendChild(humanValue);

        const humanTrack = document.createElement('div');
        humanTrack.className = 'prob-bar-track';

        const humanFill = document.createElement('div');
        humanFill.className = 'prob-bar-fill human';
        humanFill.style.width = `${humanProb}%`;
        humanTrack.appendChild(humanFill);

        humanBarItem.appendChild(humanLabel);
        humanBarItem.appendChild(humanTrack);

        probBars.appendChild(aiBarItem);
        probBars.appendChild(humanBarItem);

        // Model specs
        const specs = document.createElement('div');
        specs.className = 'model-specs';

        const specsData = [
          { label: 'Accuracy', value: metadata.accuracy },
          { label: 'Architecture', value: metadata.architecture },
          { label: 'Confidence', value: `${v.fullResult.confidence}%` },
          { label: 'Inference Time', value: `${v.time}ms` }
        ];

        specsData.forEach(spec => {
          const row = document.createElement('div');
          row.className = 'spec-row';

          const label = document.createElement('span');
          label.className = 'spec-label';
          label.textContent = spec.label;

          const value = document.createElement('span');
          value.className = 'spec-value';
          value.textContent = spec.value;

          row.appendChild(label);
          row.appendChild(value);
          specs.appendChild(row);
        });

        // Training data
        const training = document.createElement('div');
        training.className = 'model-training';

        const trainingLabel = document.createElement('div');
        trainingLabel.className = 'training-label';
        trainingLabel.textContent = 'Training Data';

        const trainingData = document.createElement('div');
        trainingData.className = 'training-data';
        trainingData.textContent = metadata.trainingData;

        training.appendChild(trainingLabel);
        training.appendChild(trainingData);

        // Assemble body
        body.appendChild(probBars);
        body.appendChild(specs);
        body.appendChild(training);

        // Assemble card
        card.appendChild(header);
        card.appendChild(body);

        modelCards.appendChild(card);
      });
    }

    // ========================================
    // Model Loading
    // ========================================

    async function loadModels() {
      // LAZY LOADING: Don't pre-load models at startup
      // Models will load on-demand during inference (with 120s timeout)
      // Just render the UI and mark models as ready to use

      renderModelCategories();

      for (const modelId of state.selectedModels) {
        const modelInfo = ModelManager.getModelInfo(modelId);
        if (!modelInfo) continue;

        // Mark as pending (will load on first inference)
        updateModelStatus(modelId, 'pending');
        state.modelsLoaded++;
      }

      elements.loadingSubtext.textContent = 'Models ready (will load on demand with 2min timeout)';

      if (state.modelsLoaded > 0) {
        updateAnalyzeButton();
      } else {
        elements.analyzeBtn.querySelector('.btn-text').textContent = 'No models selected';
      }
    }

    // ========================================
    // Category Button Handlers
    // ========================================

    function setupCategoryButtons() {
      // Model category buttons removed - single model UI now
      // Keep null checks for backwards compatibility if elements are re-added
      if (elements.fullImageSelectAll) {
        elements.fullImageSelectAll.onclick = () => {
          ModelManager.getModelsByCategory('FULL_IMAGE_DETECTORS').forEach(m => state.selectedModels.add(m.id));
          renderModelCategories();
          updateAnalyzeButton();
        };
      }
      if (elements.fullImageClear) {
        elements.fullImageClear.onclick = () => {
          ModelManager.getModelsByCategory('FULL_IMAGE_DETECTORS').forEach(m => state.selectedModels.delete(m.id));
          renderModelCategories();
          updateAnalyzeButton();
        };
      }
      if (elements.faceManipulationSelectAll) {
        elements.faceManipulationSelectAll.onclick = () => {
          ModelManager.getModelsByCategory('FACE_MANIPULATION_DETECTORS').forEach(m => state.selectedModels.add(m.id));
          renderModelCategories();
          updateAnalyzeButton();
        };
      }
      if (elements.faceManipulationClear) {
        elements.faceManipulationClear.onclick = () => {
          ModelManager.getModelsByCategory('FACE_MANIPULATION_DETECTORS').forEach(m => state.selectedModels.delete(m.id));
          renderModelCategories();
          updateAnalyzeButton();
        };
      }
    }

    // ========================================
    // Initialization
    // ========================================

    async function init() {
      try {
        elements.loadingOverlay.style.display = 'flex';

        // Initialize matrix rain
        initMatrixRain();

        // Initialize inference engine
        elements.loadingSubtext.textContent = 'Detecting WebGPU support...';
        await InferenceEngine.init();

        // Update backend indicator
        const backend = InferenceEngine.getBackend();
        updateBackendIndicator(backend);

        // Update model card status
        updateModelCardStatus('', 'Initializing...');

        // Load models (lazy - marks ready but doesn't download)
        await loadModels();

        // Mark model as ready
        updateModelCardStatus('ready', 'Ready');

        // Setup event listeners
        setupCategoryButtons();
        setupUploadHandlers();
        setupClipboardPaste();
        setupAnalyzeButton();
        setupNewAnalysisButton();
        setupClearCacheButton();
        setupCollapsibleSections();

        // Restore persisted image if any (crash recovery)
        await restorePersistedImage();

        // Hide loading overlay
        setTimeout(() => {
          elements.loadingOverlay.style.opacity = '0';
          setTimeout(() => {
            elements.loadingOverlay.style.display = 'none';
          }, 300);
        }, 500);

      } catch (error) {
        console.error('Initialization failed:', error);
        elements.loadingSubtext.textContent = 'Error: ' + error.message;
        elements.loadingSubtext.style.color = '#ff4444';
      }
    }

    // ========================================
    // Start Application
    // ========================================

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>

  <!-- Service Worker Registration for Caching & Offline Support -->
  <script>
    // Register Service Worker for intelligent caching
    if ('serviceWorker' in navigator && !window.__SKIP_SW_REGISTRATION__) {
      window.addEventListener('load', async () => {
        try {
          const registration = await navigator.serviceWorker.register('/service-worker.js', {
            scope: '/'
          });

          console.log('[App] Service Worker registered:', registration.scope);

          // Check for updates periodically
          setInterval(() => {
            registration.update();
          }, 60000); // Check every minute

          // Handle update found
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                console.log('[App] New Service Worker version available');
                // Show non-blocking update notification
                if (typeof showUpdateNotification === 'function') {
                  showUpdateNotification(() => {
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                    window.location.reload();
                  });
                } else {
                  console.warn('[App] showUpdateNotification not available, auto-reloading');
                  newWorker.postMessage({ type: 'SKIP_WAITING' });
                  window.location.reload();
                }
              }
            });
          });

          // Controller change listener (when new SW takes over)
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            console.log('[App] Service Worker controller changed');
          });

        } catch (error) {
          console.error('[App] Service Worker registration failed:', error);
        }
      });

      // Message handler for SW communication
      navigator.serviceWorker.addEventListener('message', (event) => {
        const { type, data } = event.data;
        console.log('[App] Message from SW:', type, data);
      });
    } else if (!window.__SKIP_SW_REGISTRATION__) {
      console.warn('[App] Service Worker not supported');
    } else {
      console.log('[App] Service Worker registration skipped (cache clearing in progress)');
    }
  </script>

  <!-- Cache Busting: Force update on deployment -->
  <script>
    (function() {
      const SITE_VERSION = 'v2.4.1'; // Must match service-worker.js CACHE_VERSION
      const lastVersion = localStorage.getItem('siteVersion');

      if (lastVersion && lastVersion !== SITE_VERSION) {
        console.log('[CacheBust] Version changed from', lastVersion, 'to', SITE_VERSION, '- clearing cache');

        // Prevent SW registration on this page load (flag checked below)
        window.__SKIP_SW_REGISTRATION__ = true;

        // Clear all caches
        if ('caches' in window) {
          caches.keys().then(names => {
            names.forEach(name => {
              console.log('[CacheBust] Deleting cache:', name);
              caches.delete(name);
            });
          });
        }

        // Unregister service workers and wait for completion
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.getRegistrations().then(regs => {
            Promise.all(regs.map(reg => {
              console.log('[CacheBust] Unregistering SW');
              return reg.unregister();
            })).then(() => {
              // Mark version and reload after SW unregistered
              localStorage.setItem('siteVersion', SITE_VERSION);

              // Reload once (prevent infinite reload)
              if (!sessionStorage.getItem('cacheCleared')) {
                sessionStorage.setItem('cacheCleared', 'true');
                console.log('[CacheBust] Reloading page...');
                window.location.reload(true);
              }
            });
          });
        } else {
          // No SW support, just reload
          localStorage.setItem('siteVersion', SITE_VERSION);
          if (!sessionStorage.getItem('cacheCleared')) {
            sessionStorage.setItem('cacheCleared', 'true');
            window.location.reload(true);
          }
        }
      } else {
        // First visit or same version
        localStorage.setItem('siteVersion', SITE_VERSION);
      }
    })();
  </script>
</body>
</html>
