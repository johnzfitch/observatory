<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Execution Trace Test</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0f;
      color: #00ff88;
      padding: 20px;
      line-height: 1.4;
    }
    h1 { color: #00ccff; border-bottom: 2px solid #00ccff; padding-bottom: 10px; }
    h2 { color: #ff6600; margin-top: 30px; }

    .controls {
      margin: 20px 0;
      padding: 15px;
      background: #111;
      border: 1px solid #333;
      border-radius: 8px;
    }

    button {
      background: #00ccff;
      color: #000;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover { background: #00ff88; }
    button:disabled { background: #444; color: #888; cursor: not-allowed; }

    .log-container {
      background: #000;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      max-height: 600px;
      overflow-y: auto;
      font-size: 12px;
    }

    .log-entry {
      padding: 2px 0;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .log-start { color: #00ccff; }
    .log-end { color: #00ff88; }
    .log-success { color: #00ff88; }
    .log-error { color: #ff4444; }
    .log-warn { color: #ffaa00; }
    .log-info { color: #888; }

    .summary {
      background: #111;
      border: 1px solid #00ccff;
      border-radius: 8px;
      padding: 15px;
      margin: 20px 0;
    }

    .summary h3 { color: #00ccff; margin-top: 0; }
    .summary pre { margin: 0; color: #00ff88; }

    .model-select {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }

    .model-select label {
      display: flex;
      align-items: center;
      padding: 8px;
      background: #111;
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
    }

    .model-select label:hover { border-color: #00ccff; }
    .model-select input { margin-right: 8px; }
  </style>
</head>
<body>
  <h1>[TEST] Execution Trace Test</h1>
  <p>Comprehensive tracing of model inference pipeline</p>

  <div class="controls">
    <h3>Model Selection</h3>
    <div class="model-select" id="modelSelect">
      <label><input type="checkbox" value="dima806_ai_real" checked> Dima806 AI vs Real</label>
      <label><input type="checkbox" value="smogy" checked> SMOGY AI Detector</label>
      <label><input type="checkbox" value="haywood"> Haywood SwinV2</label>
      <label><input type="checkbox" value="umm_maybe"> Umm-Maybe AI Detector</label>
      <label><input type="checkbox" value="prithiv_v2"> Prithiv Deepfake v2</label>
      <label><input type="checkbox" value="ateeqq"> Ateeqq (Flux/SDXL)</label>
    </div>

    <h3>Actions</h3>
    <button onclick="runTracedInference()">Run Traced Inference</button>
    <button onclick="recreateUserLog()">Recreate User Log Flow</button>
    <button onclick="validateCurrentTraces()">Validate Traces</button>
    <button onclick="exportTraces()">Export Traces</button>
    <button onclick="clearLog()">Clear Log</button>
  </div>

  <h2>Execution Log</h2>
  <div class="log-container" id="logContainer"></div>

  <div id="summaryContainer"></div>

  <script type="module">
    import { tracer, startTrace, endTrace, trace, resetTracer, exportTraces as exportTracesFunc } from './src/utils/tracer.js';

    const logContainer = document.getElementById('logContainer');
    const summaryContainer = document.getElementById('summaryContainer');

    // Intercept console.log to display in our UI
    const originalLog = console.log;
    console.log = function(...args) {
      originalLog.apply(console, args);

      const entry = document.createElement('div');
      entry.className = 'log-entry';

      const text = args.map(a =>
        typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a)
      ).join(' ');

      entry.textContent = text;

      // Color coding based on content
      if (text.includes('START') || text.includes('[START]')) entry.className += ' log-start';
      else if (text.includes('END') || text.includes('[END]')) entry.className += ' log-end';
      else if (text.includes('SUCCESS') || text.includes('[OK]')) entry.className += ' log-success';
      else if (text.includes('ERROR') || text.includes('[ERROR]')) entry.className += ' log-error';
      else if (text.includes('WARN') || text.includes('[WARN]')) entry.className += ' log-warn';
      else entry.className += ' log-info';

      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    };

    window.clearLog = () => {
      logContainer.textContent = '';
      summaryContainer.textContent = '';
    };

    window.exportTraces = () => {
      const traces = exportTracesFunc();
      const blob = new Blob([JSON.stringify(traces, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `trace-${Date.now()}.json`;
      a.click();
      console.log('[OK] Traces exported');
    };

    /**
     * Recreate the exact log flow from user's test2c.log
     */
    window.recreateUserLog = async () => {
      clearLog();
      resetTracer();

      console.log('='.repeat(70));
      console.log('RECREATING USER LOG FLOW FROM test2c.log');
      console.log('='.repeat(70));

      const span = startTrace('user-flow', 'User Log Recreation');

      // Step 1: ONNX Init
      trace('user-flow', 'INFO', '[ONNX-Init] Pre-configuring ONNX Runtime environment...');
      await sleep(50);
      trace('user-flow', 'INFO', '[ONNX-Init] WASM paths pre-configured: /vendor/');
      trace('user-flow', 'SUCCESS', '[ONNX-Init] Configuration complete');

      // Step 2: InferenceEngine Init
      trace('user-flow', 'INFO', '[InferenceEngine] Initializing...');
      await sleep(50);
      trace('user-flow', 'INFO', '[InferenceEngine] FORCE_WASM enabled - bypassing WebGPU detection');
      trace('user-flow', 'SUCCESS', '[InferenceEngine] Initialized with WASM backend (forced)');

      // Step 3: Model Loading (dima806_ai_real)
      const modelSpan = startTrace('dima806_ai_real', 'Model Load: dima806_ai_real');
      trace('dima806_ai_real', 'START', '[START] Starting model load process...');
      trace('dima806_ai_real', 'INFO', '[LOAD] Importing transformers.js from CDN');
      await sleep(200);
      trace('dima806_ai_real', 'SUCCESS', '[OK] Transformers.js imported successfully');
      trace('dima806_ai_real', 'INFO', 'pipeline function available: true');
      trace('dima806_ai_real', 'INFO', 'env object available: true');

      trace('dima806_ai_real', 'INFO', '[CONFIG]  Configuring transformers.js environment...');
      trace('dima806_ai_real', 'SUCCESS', '[paths.js] [OK] allowLocalModels = true');
      trace('dima806_ai_real', 'SUCCESS', '[paths.js] [OK] useBrowserCache = true');
      trace('dima806_ai_real', 'SUCCESS', '[paths.js] [OK] localModelPath = /models/');
      trace('dima806_ai_real', 'SUCCESS', '[paths.js] [OK] allowRemoteModels = false');
      trace('dima806_ai_real', 'INFO', '[paths.js] [INFO]  WASM paths NOT configured - using transformers.js bundled ONNX Runtime');
      trace('dima806_ai_real', 'INFO', '[paths.js] Current WASM paths: https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.1.2/dist/');
      trace('dima806_ai_real', 'SUCCESS', '[OK] Environment configured');

      trace('dima806_ai_real', 'INFO', '[BUILD] Creating pipeline...');
      trace('dima806_ai_real', 'INFO', 'Task: image-classification');
      trace('dima806_ai_real', 'INFO', 'Model: dima806_ai_real');
      trace('dima806_ai_real', 'INFO', 'Device: wasm');
      await sleep(800);

      trace('dima806_ai_real', 'INFO', 'Loading ONNX model from: http://localhost:8000/models/dima806_ai_real/onnx/model.onnx');
      await sleep(1000);
      trace('dima806_ai_real', 'SUCCESS', '[SUCCESS] Pipeline created successfully!');
      trace('dima806_ai_real', 'SUCCESS', '[END] Load process complete (isLoading = false)');
      endTrace(modelSpan, { modelId: 'dima806_ai_real' });

      // Step 4: Inference
      const inferenceSpan = startTrace('inference', 'Inference Execution');
      trace('inference', 'INFO', '[InferenceEngine] Running inference with 1 model');
      trace('inference', 'INFO', '[InferenceEngine] Backend: wasm');
      trace('inference', 'INFO', '[InferenceEngine] [OK] Model ID validated: dima806_ai_real');
      trace('inference', 'INFO', '[InferenceEngine] [OK] Model already loaded');
      trace('inference', 'INFO', '[InferenceEngine] [RUN] Running prediction...');

      trace('dima806_ai_real', 'INFO', '[RUN] predict() called');
      trace('dima806_ai_real', 'INFO', 'imageSource type: String (data URL)');
      trace('dima806_ai_real', 'INFO', '[EXEC] Running classifier...');

      await sleep(500);

      trace('dima806_ai_real', 'SUCCESS', '[OK] Classifier returned results:');
      trace('dima806_ai_real', 'SUCCESS', 'Array [ {label: "ai", score: 0.969}, {label: "real", score: 0.031} ]');
      trace('dima806_ai_real', 'INFO', 'aiProbability: 96.9');
      trace('dima806_ai_real', 'INFO', 'verdict: AI');
      trace('dima806_ai_real', 'INFO', 'confidence: 93.8');

      trace('inference', 'SUCCESS', '[InferenceEngine] [OK] Prediction complete');
      trace('inference', 'SUCCESS', 'Result: { aiProbability: 96.9, verdict: "AI", confidence: 93.8 }');
      endTrace(inferenceSpan, { success: true });

      endTrace(span, { totalModels: 1, success: true });

      console.log('='.repeat(70));
      displaySummary();
    };

    /**
     * Run actual traced inference
     */
    window.runTracedInference = async () => {
      clearLog();
      resetTracer();

      console.log('='.repeat(70));
      console.log('RUNNING TRACED INFERENCE');
      console.log('='.repeat(70));

      const mainSpan = startTrace('main', 'Full Inference Pipeline');

      try {
        // Get selected models
        const checkboxes = document.querySelectorAll('#modelSelect input:checked');
        const selectedModels = Array.from(checkboxes).map(cb => cb.value);

        if (selectedModels.length === 0) {
          throw new Error('No models selected');
        }

        trace('main', 'INFO', `Selected models: ${selectedModels.join(', ')}`);

        // Create test image
        const imageSpan = startTrace('image', 'Create Test Image');
        trace('image', 'INFO', 'Creating 224x224 gradient test image...');

        const canvas = document.createElement('canvas');
        canvas.width = 224;
        canvas.height = 224;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 224, 224);
        gradient.addColorStop(0, '#ff0000');
        gradient.addColorStop(1, '#0000ff');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 224, 224);

        const dataUrl = canvas.toDataURL('image/png');
        trace('image', 'SUCCESS', `[OK] Image created (${dataUrl.length} chars)`);
        endTrace(imageSpan);

        // Load and run each model
        const results = [];
        for (const modelId of selectedModels) {
          const modelSpan = startTrace(modelId, `Model: ${modelId}`);

          try {
            trace(modelId, 'INFO', `[LOAD] Importing model module...`);
            const model = await import(`./src/models/${modelId}.js`);
            trace(modelId, 'SUCCESS', `[OK] Module imported`);

            trace(modelId, 'INFO', `âš¡ Loading model...`);
            await model.load({ device: 'wasm' });
            trace(modelId, 'SUCCESS', `[OK] Model loaded`);

            trace(modelId, 'INFO', `[RUN] Running prediction...`);
            const startTime = performance.now();
            const result = await model.predict(dataUrl);
            const duration = Math.round(performance.now() - startTime);

            trace(modelId, 'SUCCESS', `[OK] Prediction complete (${duration}ms)`);
            trace(modelId, 'SUCCESS', `Result: ${JSON.stringify(result)}`);

            results.push({ modelId, result, duration });
            endTrace(modelSpan, { success: true, duration });

          } catch (error) {
            trace(modelId, 'ERROR', `[ERROR] Error: ${error.message}`);
            trace(modelId, 'ERROR', `Stack: ${error.stack}`);
            endTrace(modelSpan, { success: false, error: error.message });
            results.push({ modelId, error: error.message, duration: 0 });
          }
        }

        // Summary
        trace('main', 'SUCCESS', '[SUCCESS] All models completed');
        trace('main', 'INFO', `Total results: ${results.length}`);
        const totalDuration = results.reduce((sum, r) => sum + r.duration, 0);
        trace('main', 'INFO', `Total inference time: ${totalDuration}ms`);
        trace('main', 'INFO', `Average per model: ${Math.round(totalDuration / results.length)}ms`);

        endTrace(mainSpan, {
          modelCount: selectedModels.length,
          successCount: results.filter(r => !r.error).length,
          totalDuration
        });

      } catch (error) {
        trace('main', 'ERROR', `[ERROR] Fatal error: ${error.message}`);
        trace('main', 'ERROR', `Stack: ${error.stack}`);
        endTrace(mainSpan, { success: false, error: error.message });
      }

      console.log('='.repeat(70));
      displaySummary();
    };

    function displaySummary() {
      const summary = tracer.getSummary();

      const container = document.createElement('div');
      container.className = 'summary';

      const heading = document.createElement('h3');
      heading.textContent = 'Execution Summary';
      container.appendChild(heading);

      const pre = document.createElement('pre');
      pre.textContent = `Total Spans: ${summary.totalTraces}

Traces:
${summary.traces.map((t, i) =>
  `${i + 1}. ${t.label} (${t.id})
   Duration: ${Math.round(t.duration)}ms
   Logs: ${t.logCount}`
).join('\n\n')}`;

      container.appendChild(pre);
      summaryContainer.textContent = '';
      summaryContainer.appendChild(container);
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  </script>
</body>
</html>

  <!-- Add validation button after Export button -->
  <script type="module">
    import { validateTraces } from './src/utils/trace-validator.js';

    window.validateCurrentTraces = () => {
      const traces = tracer.export().traces;
      const result = validateTraces(traces);
      
      console.log('');
      console.log('Validation Result:', result.valid ? '[SUCCESS] PASSED' : '[ERROR] FAILED');
      console.log('Violations:', result.violations.length);
      console.log('Warnings:', result.warnings.length);
    };
  </script>
