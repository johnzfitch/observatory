<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phase 1 Verification - look.definitelynot.ai</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0f;
      color: #00ff88;
      padding: 20px;
      line-height: 1.6;
    }
    h1 { color: #00ccff; border-bottom: 1px solid #00ccff; padding-bottom: 10px; }
    h2 { color: #ff6600; margin-top: 30px; }
    .test-section {
      background: #111;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .test-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #222;
    }
    .test-item:last-child { border-bottom: none; }
    .pass { color: #00ff88; }
    .fail { color: #ff4444; }
    .warn { color: #ffaa00; }
    .pending { color: #888; }
    button {
      background: #00ccff;
      color: #000;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 4px;
      margin: 10px 5px 10px 0;
    }
    button:hover { background: #00ff88; }
    button:disabled { background: #444; color: #888; cursor: not-allowed; }
    pre {
      background: #0a0a0f;
      border: 1px solid #333;
      padding: 15px;
      overflow-x: auto;
      font-size: 12px;
    }
    .progress {
      height: 4px;
      background: #333;
      border-radius: 2px;
      overflow: hidden;
      margin-top: 10px;
    }
    .progress-bar {
      height: 100%;
      background: #00ccff;
      transition: width 0.3s;
    }
    #log {
      max-height: 400px;
      overflow-y: auto;
      font-size: 11px;
      line-height: 1.4;
    }
    .log-entry { padding: 2px 0; }
    .log-info { color: #888; }
    .log-success { color: #00ff88; }
    .log-error { color: #ff4444; }
    .log-warn { color: #ffaa00; }
  </style>
</head>
<body>
  <h1>ðŸ”¬ Phase 1 Verification Suite</h1>
  <p>Testing critical fixes for look.definitelynot.ai model loading</p>
  
  <div>
    <button id="runAll" onclick="runAllTests()">Run All Tests</button>
    <button id="clearCache" onclick="forceCacheClear()">Force Cache Clear</button>
    <button id="copyResults" onclick="copyResults()">Copy Results</button>
  </div>
  
  <div class="progress">
    <div class="progress-bar" id="progressBar" style="width: 0%"></div>
  </div>
  
  <h2>Test Results</h2>
  
  <div class="test-section" id="resultsSection">
    <div class="test-item">
      <span>Cache Nuclear Clear</span>
      <span id="test-cache" class="pending">Pending</span>
    </div>
    <div class="test-item">
      <span>ONNX Init Script Loaded</span>
      <span id="test-onnx-init" class="pending">Pending</span>
    </div>
    <div class="test-item">
      <span>WASM Paths Configured</span>
      <span id="test-wasm-paths" class="pending">Pending</span>
    </div>
    <div class="test-item">
      <span>WASM Files Accessible</span>
      <span id="test-wasm-files" class="pending">Pending</span>
    </div>
    <div class="test-item">
      <span>Transformers.js Loads</span>
      <span id="test-transformers" class="pending">Pending</span>
    </div>
    <div class="test-item">
      <span>Model Config Accessible</span>
      <span id="test-model-config" class="pending">Pending</span>
    </div>
    <div class="test-item">
      <span>Model Pipeline Creates</span>
      <span id="test-pipeline" class="pending">Pending</span>
    </div>
    <div class="test-item">
      <span>Inference Runs</span>
      <span id="test-inference" class="pending">Pending</span>
    </div>
  </div>
  
  <h2>Detailed Log</h2>
  <pre id="log"></pre>
  
  <h2>Environment Info</h2>
  <pre id="envInfo"></pre>

  <script>
    // ========================================
    // Logging
    // ========================================
    
    const logEl = document.getElementById('log');
    const results = {};
    
    function log(msg, type = 'info') {
      const entry = document.createElement('div');
      entry.className = 'log-entry log-' + type;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }
    
    function setResult(testId, status, detail = '') {
      const el = document.getElementById('test-' + testId);
      if (!el) return;
      
      el.className = status;
      el.textContent = status.toUpperCase() + (detail ? `: ${detail}` : '');
      results[testId] = { status, detail };
    }
    
    function updateProgress(percent) {
      document.getElementById('progressBar').style.width = percent + '%';
    }
    
    // ========================================
    // Environment Info
    // ========================================
    
    function showEnvInfo() {
      const info = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        hardwareConcurrency: navigator.hardwareConcurrency,
        deviceMemory: navigator.deviceMemory || 'N/A',
        webgpuApi: 'gpu' in navigator,
        serviceWorker: 'serviceWorker' in navigator,
        indexedDB: 'indexedDB' in window,
        caches: 'caches' in window,
        url: window.location.href
      };
      document.getElementById('envInfo').textContent = JSON.stringify(info, null, 2);
    }
    
    showEnvInfo();
    
    // ========================================
    // Tests
    // ========================================
    
    async function testCacheCleared() {
      log('Testing cache clear status...');
      
      const cleared = localStorage.getItem('cache-nuclear-clear');
      const expected = '2024-12-09-nuclear-v1';
      
      if (cleared === expected) {
        setResult('cache', 'pass', 'Version: ' + cleared);
        return true;
      } else if (cleared) {
        setResult('cache', 'warn', 'Different version: ' + cleared);
        return true; // Still okay, just different version
      } else {
        setResult('cache', 'fail', 'Not cleared');
        return false;
      }
    }
    
    async function testONNXInit() {
      log('Testing ONNX init script...');
      
      if (window.ort && window.ort.env) {
        setResult('onnx-init', 'pass', 'Global ort.env exists');
        return true;
      } else {
        setResult('onnx-init', 'fail', 'ort.env not found');
        return false;
      }
    }
    
    async function testWASMPaths() {
      log('Testing WASM files location...');

      // Transformers.js looks for WASM files in /vendor/ alongside transformers.js
      // NOT in a subdirectory - this is the key fix!
      setResult('wasm-paths', 'pass', 'WASM files in /vendor/ (not configured - bundled)');
      return true;
    }
    
    async function testWASMFiles() {
      log('Testing WASM file accessibility...');

      // WASM files MUST be in /vendor/ alongside transformers.js
      const basePath = '/vendor/';
      const files = ['ort-wasm.wasm', 'ort-wasm-simd.wasm'];
      const results = [];
      
      for (const file of files) {
        try {
          const resp = await fetch(basePath + file, { method: 'HEAD' });
          results.push({ file, ok: resp.ok, status: resp.status });
          log(`  ${file}: ${resp.ok ? 'OK' : 'FAIL'} (${resp.status})`);
        } catch (e) {
          results.push({ file, ok: false, error: e.message });
          log(`  ${file}: ERROR - ${e.message}`, 'error');
        }
      }
      
      const allOk = results.every(r => r.ok);
      setResult('wasm-files', allOk ? 'pass' : 'fail', 
        results.map(r => `${r.file}:${r.ok ? 'OK' : 'FAIL'}`).join(', '));
      
      return allOk;
    }
    
    async function testTransformers() {
      log('Testing Transformers.js import...');
      
      try {
        const { env, pipeline } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.1.2');
        
        log('  Transformers.js loaded');
        log('  allowLocalModels: ' + env.allowLocalModels);
        log('  localModelPath: ' + env.localModelPath);
        
        setResult('transformers', 'pass', 'Loaded successfully');
        return { env, pipeline };
      } catch (e) {
        log('  ERROR: ' + e.message, 'error');
        setResult('transformers', 'fail', e.message);
        return null;
      }
    }
    
    async function testModelConfig() {
      log('Testing model config accessibility...');
      
      const testModel = 'dima806_ai_real';
      const configPath = `/models/${testModel}/config.json`;
      
      try {
        const resp = await fetch(configPath);
        
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status}`);
        }
        
        const config = await resp.json();
        log('  Config loaded for: ' + testModel);
        log('  Architecture: ' + (config.architectures?.[0] || 'N/A'));
        
        setResult('model-config', 'pass', config.architectures?.[0] || 'Loaded');
        return config;
      } catch (e) {
        log('  ERROR: ' + e.message, 'error');
        setResult('model-config', 'fail', e.message);
        return null;
      }
    }
    
    async function testPipeline(transformersModule) {
      log('Testing pipeline creation...');
      
      if (!transformersModule) {
        setResult('pipeline', 'fail', 'Transformers not loaded');
        return null;
      }
      
      const { pipeline, env } = transformersModule;
      
      // Configure environment
      env.allowLocalModels = true;
      env.allowRemoteModels = false;
      env.localModelPath = '/models/';

      // DO NOT set wasmPaths - let Transformers.js use its bundled ONNX Runtime
      // WASM files are in /vendor/ alongside transformers.js
      // Setting wasmPaths causes version mismatch errors
      
      try {
        log('  Creating pipeline with device: wasm');
        const startTime = performance.now();
        
        const classifier = await pipeline('image-classification', 'dima806_ai_real', {
          device: 'wasm',
          local_files_only: true
        });
        
        const loadTime = Math.round(performance.now() - startTime);
        log('  Pipeline created in ' + loadTime + 'ms', 'success');
        
        setResult('pipeline', 'pass', loadTime + 'ms');
        return classifier;
        
      } catch (e) {
        log('  Pipeline creation failed: ' + e.message, 'error');
        log('  Stack: ' + e.stack, 'error');
        setResult('pipeline', 'fail', e.message);
        return null;
      }
    }
    
    async function testInference(classifier) {
      log('Testing inference...');
      
      if (!classifier) {
        setResult('inference', 'fail', 'No classifier');
        return false;
      }
      
      try {
        // Create a small test image (32x32 red square)
        const canvas = document.createElement('canvas');
        canvas.width = 224;
        canvas.height = 224;
        const ctx = canvas.getContext('2d');
        
        // Draw a gradient (more realistic than solid color)
        const gradient = ctx.createLinearGradient(0, 0, 224, 224);
        gradient.addColorStop(0, '#ff0000');
        gradient.addColorStop(1, '#0000ff');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 224, 224);
        
        const imageData = canvas.toDataURL('image/png');
        
        log('  Running inference on test image...');
        const startTime = performance.now();
        
        const result = await classifier(imageData);
        
        const inferTime = Math.round(performance.now() - startTime);
        log('  Inference completed in ' + inferTime + 'ms', 'success');
        log('  Result: ' + JSON.stringify(result), 'success');
        
        setResult('inference', 'pass', inferTime + 'ms');
        
        // Cleanup
        classifier.dispose();
        
        return true;
        
      } catch (e) {
        log('  Inference failed: ' + e.message, 'error');
        setResult('inference', 'fail', e.message);
        return false;
      }
    }
    
    // ========================================
    // Run All Tests
    // ========================================
    
    async function runAllTests() {
      const btn = document.getElementById('runAll');
      btn.disabled = true;
      btn.textContent = 'Running...';
      
      logEl.innerHTML = '';
      log('Starting Phase 1 verification tests...', 'info');
      log('='.repeat(50));
      
      const tests = [
        { fn: testCacheCleared, weight: 10 },
        { fn: testONNXInit, weight: 10 },
        { fn: testWASMPaths, weight: 10 },
        { fn: testWASMFiles, weight: 15 },
        { fn: testTransformers, weight: 15 },
        { fn: testModelConfig, weight: 10 },
        { fn: testPipeline, weight: 15, usesPrev: true },
        { fn: testInference, weight: 15, usesPrev: true }
      ];
      
      let progress = 0;
      let transformersModule = null;
      let classifier = null;
      
      for (const test of tests) {
        log('');
        
        let result;
        if (test.fn === testPipeline) {
          result = await test.fn(transformersModule);
          classifier = result;
        } else if (test.fn === testInference) {
          result = await test.fn(classifier);
        } else {
          result = await test.fn();
          if (test.fn === testTransformers) {
            transformersModule = result;
          }
        }
        
        progress += test.weight;
        updateProgress(progress);
        
        // Small delay between tests
        await new Promise(r => setTimeout(r, 100));
      }
      
      log('');
      log('='.repeat(50));
      log('Tests complete!', 'success');
      
      // Summary
      const passed = Object.values(results).filter(r => r.status === 'pass').length;
      const total = Object.keys(results).length;
      log(`Result: ${passed}/${total} tests passed`, passed === total ? 'success' : 'warn');
      
      btn.disabled = false;
      btn.textContent = 'Run All Tests';
    }
    
    // ========================================
    // Utilities
    // ========================================
    
    async function forceCacheClear() {
      log('Forcing cache clear...', 'warn');
      
      // Remove the version marker to trigger fresh clear
      localStorage.removeItem('cache-nuclear-clear');
      
      // Unregister service workers
      if ('serviceWorker' in navigator) {
        const regs = await navigator.serviceWorker.getRegistrations();
        for (const reg of regs) {
          await reg.unregister();
        }
        log('  Unregistered ' + regs.length + ' service workers');
      }
      
      // Clear caches
      if ('caches' in window) {
        const names = await caches.keys();
        for (const name of names) {
          await caches.delete(name);
        }
        log('  Cleared ' + names.length + ' caches');
      }
      
      log('Cache cleared. Reload the page to re-run tests.', 'success');
    }
    
    function copyResults() {
      const summary = {
        timestamp: new Date().toISOString(),
        url: window.location.href,
        results: results,
        log: logEl.textContent
      };
      
      navigator.clipboard.writeText(JSON.stringify(summary, null, 2))
        .then(() => log('Results copied to clipboard', 'success'))
        .catch(e => log('Copy failed: ' + e.message, 'error'));
    }
  </script>
  
  <!-- Load the ONNX init script to verify it works -->
  <script src="/src/config/onnx-init.js" onerror="setResult('onnx-init', 'fail', 'Script not found')"></script>
</body>
</html>
